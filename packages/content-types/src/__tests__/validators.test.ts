import { describe, expect, it } from 'vitest';
import { validateAction } from '../action/validator.js';
import { validateAudio } from '../audio/validator.js';
import { validateCommunity } from '../community/validator.js';
import { validateCompositionReference } from '../composition-reference/validator.js';
import { validateDawProject } from '../daw-project/validator.js';
import { validateGitHubIssue } from '../github-issue/validator.js';
import { validateGitHubRepository } from '../github-repository/validator.js';
import { validateHeroJourneyScene } from '../hero-journey-scene/validator.js';
import { validateHeroJourneyStage } from '../hero-journey-stage/validator.js';
import { validateImage } from '../image/validator.js';
import { validateIntegrationPolicy } from '../integration-policy/validator.js';
import { validateSensor } from '../sensor/validator.js';
import { validateSong } from '../song/validator.js';
import { validateSpatialMap } from '../spatial-map/validator.js';
import { validateStemsBundle } from '../stems-bundle/validator.js';
import { validateText } from '../text/validator.js';
import { validateThread } from '../thread/validator.js';
import { validateVariable } from '../variable/validator.js';

describe('action validator', () => {
  it('accepts valid github-pr action payload', () => {
    const result = validateAction({
      label: 'open-automation-pr',
      kind: 'github-pr',
      executionMode: 'direct-low-risk',
      riskLevel: 'low',
      trigger: {
        responsePolicyOrganismId: 'org-policy-1',
        whenDecision: 'pass',
      },
      config: {
        owner: 'omnilith-labs',
        repository: 'omnilith',
        baseBranch: 'main',
        headBranch: 'automation/issue-42',
        title: 'Automated patch',
        body: 'Generated by regulator runtime.',
      },
      cooldownSeconds: 300,
    });

    expect(result.valid).toBe(true);
  });

  it('rejects malformed trigger and config', () => {
    const result = validateAction({
      label: '',
      kind: 'github-pr',
      executionMode: 'always',
      riskLevel: 'medium',
      trigger: {
        responsePolicyOrganismId: '',
        whenDecision: 'maybe',
      },
      config: {
        owner: '',
        repository: '',
        baseBranch: '',
        headBranch: '',
        title: '',
        body: '',
      },
      cooldownSeconds: -1,
    });

    expect(result.valid).toBe(false);
    expect(result.issues).toContain('label must be a non-empty string');
    expect(result.issues).toContain("executionMode must be 'direct-low-risk' or 'proposal-required'");
    expect(result.issues).toContain('trigger.responsePolicyOrganismId must be a non-empty string');
    expect(result.issues).toContain('config.owner must be a non-empty string');
  });

  it('accepts valid open-proposal action payload', () => {
    const result = validateAction({
      label: 'open-followup-proposal',
      kind: 'open-proposal',
      executionMode: 'direct-low-risk',
      riskLevel: 'low',
      trigger: {
        responsePolicyOrganismId: 'org-policy-2',
        whenDecision: 'pass',
      },
      config: {
        targetOrganismId: 'org-target',
        proposedContentTypeId: 'text',
        proposedPayload: { content: 'follow up', format: 'markdown' },
        description: 'Open a follow-up proposal',
      },
    });

    expect(result.valid).toBe(true);
  });

  it('rejects malformed open-proposal config', () => {
    const result = validateAction({
      label: 'open-followup-proposal',
      kind: 'open-proposal',
      executionMode: 'direct-low-risk',
      riskLevel: 'low',
      trigger: {
        responsePolicyOrganismId: 'org-policy-2',
        whenDecision: 'pass',
      },
      config: {
        targetOrganismId: '',
        proposedContentTypeId: '',
      },
    });

    expect(result.valid).toBe(false);
    expect(result.issues).toContain('config.targetOrganismId must be a non-empty string');
    expect(result.issues).toContain('config.proposedContentTypeId must be a non-empty string');
    expect(result.issues).toContain('config.proposedPayload is required');
  });
});

describe('audio validator', () => {
  it('accepts a valid audio payload', () => {
    const result = validateAudio({
      fileReference: 'audio/song.mp3',
      durationSeconds: 180,
      format: 'mp3',
      sampleRate: 44100,
    });
    expect(result.valid).toBe(true);
  });

  it('rejects missing fileReference', () => {
    const result = validateAudio({ durationSeconds: 180, format: 'mp3' });
    expect(result.valid).toBe(false);
    expect(result.issues).toContain('fileReference must be a non-empty string');
  });

  it('rejects invalid format', () => {
    const result = validateAudio({
      fileReference: 'audio/song.xyz',
      durationSeconds: 180,
      format: 'xyz',
    });
    expect(result.valid).toBe(false);
  });

  it('rejects zero duration', () => {
    const result = validateAudio({
      fileReference: 'audio/song.mp3',
      durationSeconds: 0,
      format: 'mp3',
    });
    expect(result.valid).toBe(false);
  });
});

describe('text validator', () => {
  it('accepts valid markdown', () => {
    const result = validateText({
      content: '# Hello World',
      format: 'markdown',
    });
    expect(result.valid).toBe(true);
  });

  it('accepts valid plaintext', () => {
    const result = validateText({ content: 'Hello', format: 'plaintext' });
    expect(result.valid).toBe(true);
  });

  it('rejects invalid format', () => {
    const result = validateText({ content: 'Hello', format: 'html' });
    expect(result.valid).toBe(false);
  });

  it('rejects non-string content', () => {
    const result = validateText({ content: 42, format: 'plaintext' });
    expect(result.valid).toBe(false);
  });
});

describe('image validator', () => {
  it('accepts a valid image payload', () => {
    const result = validateImage({
      fileReference: 'images/photo.jpg',
      width: 1920,
      height: 1080,
      format: 'jpg',
    });
    expect(result.valid).toBe(true);
  });

  it('rejects zero dimensions', () => {
    const result = validateImage({
      fileReference: 'images/photo.jpg',
      width: 0,
      height: 1080,
      format: 'jpg',
    });
    expect(result.valid).toBe(false);
  });
});

describe('spatial-map validator', () => {
  it('accepts a valid spatial map', () => {
    const result = validateSpatialMap({
      entries: [
        { organismId: 'org-1', x: 100, y: 100 },
        { organismId: 'org-2', x: 300, y: 300 },
      ],
      width: 1000,
      height: 1000,
    });
    expect(result.valid).toBe(true);
  });

  it('rejects duplicate organism entries', () => {
    const result = validateSpatialMap({
      entries: [
        { organismId: 'org-1', x: 10, y: 20 },
        { organismId: 'org-1', x: 30, y: 40 },
      ],
      width: 1000,
      height: 1000,
    });
    expect(result.valid).toBe(false);
  });

  it('rejects invalid dimensions', () => {
    const result = validateSpatialMap({
      entries: [],
      width: -1,
      height: 1000,
    });
    expect(result.valid).toBe(false);
  });

  it('rejects overlap based on minimum separation', () => {
    const result = validateSpatialMap({
      entries: [
        { organismId: 'org-1', x: 100, y: 100 },
        { organismId: 'org-2', x: 120, y: 120 },
      ],
      width: 1000,
      height: 1000,
    });
    expect(result.valid).toBe(false);
    expect(result.issues).toContain('entries[0] overlaps entries[1]');
  });

  it('rejects removing existing entry during transition validation', () => {
    const result = validateSpatialMap(
      {
        entries: [{ organismId: 'org-1', x: 100, y: 100 }],
        width: 1000,
        height: 1000,
      },
      {
        previousPayload: {
          entries: [
            { organismId: 'org-1', x: 100, y: 100 },
            { organismId: 'org-2', x: 300, y: 300 },
          ],
          width: 1000,
          height: 1000,
        },
      },
    );

    expect(result.valid).toBe(false);
    expect(result.issues).toContain('existing entry removed: org-2');
  });
});

describe('composition-reference validator', () => {
  it('accepts a valid composition reference', () => {
    const result = validateCompositionReference({
      entries: [
        { organismId: 'org-1', position: 0 },
        { organismId: 'org-2', position: 1 },
      ],
      arrangementType: 'sequential',
    });
    expect(result.valid).toBe(true);
  });

  it('rejects invalid arrangement type', () => {
    const result = validateCompositionReference({
      entries: [],
      arrangementType: 'random',
    });
    expect(result.valid).toBe(false);
  });

  it('rejects negative positions', () => {
    const result = validateCompositionReference({
      entries: [{ organismId: 'org-1', position: -1 }],
      arrangementType: 'sequential',
    });
    expect(result.valid).toBe(false);
  });
});

describe('thread validator', () => {
  it('accepts a valid thread creation payload', () => {
    const result = validateThread({
      title: 'Discussion about the album',
      appendOnly: true,
    });
    expect(result.valid).toBe(true);
  });

  it('rejects empty title', () => {
    const result = validateThread({ title: '', appendOnly: true });
    expect(result.valid).toBe(false);
  });

  it('accepts a valid thread post payload', () => {
    const result = validateThread({
      author: 'usr-1',
      content: 'I think we should change the intro.',
      timestamp: Date.now(),
    });
    expect(result.valid).toBe(true);
  });

  it('rejects a post with missing content', () => {
    const result = validateThread({
      author: 'usr-1',
      timestamp: Date.now(),
    });
    expect(result.valid).toBe(false);
  });
});

describe('community validator', () => {
  it('accepts a valid community payload', () => {
    const result = validateCommunity({
      description: 'A collective of field recordists.',
      mapOrganismId: 'org-1',
    });
    expect(result.valid).toBe(true);
  });

  it('rejects missing description', () => {
    const result = validateCommunity({ mapOrganismId: 'org-1' });
    expect(result.valid).toBe(false);
    expect(result.issues).toContain('description must be a non-empty string');
  });

  it('rejects missing mapOrganismId', () => {
    const result = validateCommunity({ description: 'A community.' });
    expect(result.valid).toBe(false);
    expect(result.issues).toContain('mapOrganismId must be a non-empty string');
  });

  it('rejects non-object payload', () => {
    const result = validateCommunity('not an object');
    expect(result.valid).toBe(false);
    expect(result.issues).toContain('Payload must be an object');
  });
});

describe('integration-policy validator', () => {
  it('accepts a valid single-integrator policy', () => {
    const result = validateIntegrationPolicy({
      mode: 'single-integrator',
      integratorId: 'usr-1',
    });
    expect(result.valid).toBe(true);
  });

  it('rejects unknown mode', () => {
    const result = validateIntegrationPolicy({
      mode: 'multi-approver',
      integratorId: 'usr-1',
    });
    expect(result.valid).toBe(false);
  });

  it('rejects missing integratorId', () => {
    const result = validateIntegrationPolicy({
      mode: 'single-integrator',
    });
    expect(result.valid).toBe(false);
  });
});

describe('github-repository validator', () => {
  it('accepts a valid repository payload', () => {
    const result = validateGitHubRepository({
      provider: 'github',
      owner: 'omnilith-labs',
      name: 'omnilith',
      defaultBranch: 'main',
      repositoryUrl: 'https://github.com/omnilith-labs/omnilith',
      installationRef: 'inst-123',
      sync: {
        status: 'synced',
        lastSyncedAt: Date.now(),
      },
    });

    expect(result.valid).toBe(true);
  });

  it('rejects invalid provider and url', () => {
    const result = validateGitHubRepository({
      provider: 'gitlab',
      owner: 'omnilith-labs',
      name: 'omnilith',
      defaultBranch: 'main',
      repositoryUrl: 'not-a-url',
      sync: { status: 'pending' },
    });

    expect(result.valid).toBe(false);
    expect(result.issues).toContain("provider must be 'github'");
    expect(result.issues).toContain('repositoryUrl must be a valid http(s) URL');
  });
});

describe('github-issue validator', () => {
  it('accepts a valid issue payload', () => {
    const result = validateGitHubIssue({
      repositoryOrganismId: 'org-repo',
      sourceProposalId: 'prp-1',
      sourceOrganismId: 'org-feature',
      externalIssueNumber: 42,
      externalIssueUrl: 'https://github.com/omnilith-labs/omnilith/issues/42',
      title: 'Fix renderer fallback',
      body: 'Body',
      state: 'open',
      labels: ['automation', 'poc'],
      sync: { status: 'synced', lastSyncedAt: Date.now() },
    });

    expect(result.valid).toBe(true);
  });

  it('rejects invalid linkage and labels', () => {
    const result = validateGitHubIssue({
      repositoryOrganismId: '',
      sourceProposalId: '',
      sourceOrganismId: '',
      externalIssueNumber: 0,
      title: '',
      body: 123,
      state: 'draft',
      labels: ['ok', ''],
      sync: { status: 'pending' },
    });

    expect(result.valid).toBe(false);
    expect(result.issues).toContain('repositoryOrganismId must be a non-empty string');
    expect(result.issues).toContain('sourceProposalId must be a non-empty string');
    expect(result.issues).toContain('labels[1] must be a non-empty string');
  });
});

describe('sensor validator', () => {
  it('accepts github-issues metric for external issue sensing', () => {
    const result = validateSensor({
      label: 'github-issue-pressure',
      targetOrganismId: 'org-issue',
      metric: 'github-issues',
      readings: [{ value: 1, sampledAt: Date.now() }],
    });

    expect(result.valid).toBe(true);
  });
});

describe('variable validator', () => {
  it('accepts computation-driven variable payloads', () => {
    const result = validateVariable({
      label: 'issue-pressure',
      value: 2,
      unit: 'issues',
      computation: {
        mode: 'observation-sum',
        sensorLabel: 'github-issue-pressure',
        metric: 'github-issues',
        windowSeconds: 3600,
        clampMin: 0,
      },
      computedAt: Date.now(),
    });

    expect(result.valid).toBe(true);
  });

  it('rejects malformed computation config', () => {
    const result = validateVariable({
      label: 'issue-pressure',
      value: 2,
      computation: {
        mode: 'unknown-mode',
        sensorLabel: '',
        metric: '',
      },
      computedAt: Date.now(),
    });

    expect(result.valid).toBe(false);
    expect(result.issues).toContain("computation.mode must be 'observation-sum'");
    expect(result.issues).toContain('computation.sensorLabel must be a non-empty string');
    expect(result.issues).toContain('computation.metric must be a non-empty string');
  });
});

describe('song validator', () => {
  it('accepts valid song payload', () => {
    const result = validateSong({
      title: 'Signal Bloom',
      artistCredit: 'Omnilith Ensemble',
      status: 'mixing',
    });
    expect(result.valid).toBe(true);
  });
});

describe('daw-project validator', () => {
  it('accepts valid daw project payload', () => {
    const result = validateDawProject({
      fileReference: 'dev/projects/song-v2.als',
      daw: 'ableton-live',
      format: 'als',
    });
    expect(result.valid).toBe(true);
  });
});

describe('stems-bundle validator', () => {
  it('accepts valid stems bundle payload', () => {
    const result = validateStemsBundle({
      fileReference: 'dev/stems/song-v3.zip',
      format: 'zip',
      stemCount: 12,
      sampleRate: 48000,
      bitDepth: 24,
    });
    expect(result.valid).toBe(true);
  });
});

describe('hero-journey-scene validator', () => {
  it('accepts hero journey scene payload without inline chapters', () => {
    const result = validateHeroJourneyScene({
      title: "Hero's Journey",
      subtitle: 'Composed stages carry narrative structure.',
    });
    expect(result.valid).toBe(true);
  });

  it('accepts valid hero journey scene payload', () => {
    const result = validateHeroJourneyScene({
      title: "Hero's Journey",
      subtitle: 'Concept album demo',
      chapters: [
        {
          phase: 'Call',
          title: 'The Signal',
          summary: 'A quiet transmission breaks the ordinary world.',
        },
      ],
    });
    expect(result.valid).toBe(true);
  });
});

describe('hero-journey-stage validator', () => {
  it('accepts valid hero journey stage payload', () => {
    const result = validateHeroJourneyStage({
      stageId: 'call-to-adventure',
      phase: 'Call',
      title: 'Call to Adventure',
      summary: 'The ordinary world is interrupted by a signal.',
      accentColor: '#64b2d0',
    });
    expect(result.valid).toBe(true);
  });

  it('rejects missing stageId', () => {
    const result = validateHeroJourneyStage({
      phase: 'Call',
      title: 'Call to Adventure',
      summary: 'The ordinary world is interrupted by a signal.',
    });
    expect(result.valid).toBe(false);
    expect(result.issues).toContain('stageId must be a non-empty string');
  });
});
