# Regulatory Loop Playbook

Status: Active implementation playbook  
Updated: February 21, 2026  
Audience: Founders, maintainers, agents  
Canonicality: Implementation guide (defers to `docs/FOUNDATION.md`, `docs/ORGANISM-MODEL.md`, `docs/DECISION-LOG.md`)

## Purpose

Use this playbook to compose regulatory loops from organisms with repeatable, low-risk steps.

This guide is operational. It is for thresholding organisms, composing them into a boundary, wiring runtime configuration, and verifying that the loop is alive.

## Loop Shape

A boundary becomes cybernetic by composition:

1. Sensor organism
2. Variable organism
3. Response policy organism
4. Optional action organism

The regulator runtime reads direct children of each boundary organism and performs one deterministic cycle:

1. Read sensor observations from events (`organism.observed`)
2. Update managed variable organisms
3. Update response policy organisms (`currentVariableValue`)
4. Evaluate action organisms (direct execution or open proposal)

## Prerequisites

1. API and web are running (`pnpm run dev:v1-demo`).
2. You can threshold and compose organisms.
3. You know the boundary organism ID you want to regulate.
4. If using workers, `DATABASE_URL` is configured.

Worker commands:

```bash
pnpm github:dispatch-issues
pnpm regulator:run
```

## Content Type Payloads

Use these state payload shapes when thresholding loop organisms.

Sensor (`contentTypeId: sensor`):

```json
{
  "label": "github-issue-pressure",
  "targetOrganismId": "org-boundary",
  "metric": "github-issues",
  "readings": []
}
```

Variable (`contentTypeId: variable`):

```json
{
  "label": "issue-pressure",
  "value": 0,
  "unit": "issues",
  "computedAt": 1730000000000,
  "computation": {
    "mode": "observation-sum",
    "sensorLabel": "github-issue-pressure",
    "metric": "github-issues",
    "windowSeconds": 3600
  }
}
```

Response policy (`contentTypeId: response-policy`):

```json
{
  "mode": "variable-threshold",
  "variableLabel": "issue-pressure",
  "condition": "above",
  "threshold": 3,
  "action": "decline-all",
  "reason": "Issue pressure is high."
}
```

Action (`contentTypeId: action`, internal proposal path):

```json
{
  "label": "Open follow-up proposal",
  "kind": "open-proposal",
  "executionMode": "direct-low-risk",
  "riskLevel": "low",
  "trigger": {
    "responsePolicyOrganismId": "org-response-policy",
    "whenDecision": "pass"
  },
  "config": {
    "targetOrganismId": "org-target",
    "proposedContentTypeId": "text",
    "proposedPayload": {
      "content": "Regulator follow-up",
      "format": "markdown"
    },
    "description": "Regulator action proposal"
  }
}
```

Action (`contentTypeId: action`, GitHub PR path):

```json
{
  "label": "Open GitHub PR",
  "kind": "github-pr",
  "executionMode": "direct-low-risk",
  "riskLevel": "low",
  "trigger": {
    "responsePolicyOrganismId": "org-response-policy",
    "whenDecision": "pass"
  },
  "config": {
    "owner": "omnilith-labs",
    "repository": "omnilith",
    "baseBranch": "main",
    "headBranch": "automation/issue-pressure",
    "title": "Regulator PR",
    "body": "Generated by regulator loop",
    "draft": true
  }
}
```

GitHub repository twin (`contentTypeId: github-repository`):

```json
{
  "provider": "github",
  "owner": "omnilith-labs",
  "name": "omnilith",
  "defaultBranch": "main",
  "repositoryUrl": "https://github.com/omnilith-labs/omnilith",
  "sync": {
    "status": "synced"
  }
}
```

## Recipe A: Internal Proposal Pressure Loop

Goal: integrate proposal activity into a sensor signal and use it for response policy behavior.

1. Threshold a boundary organism.
2. Threshold a sensor organism with:
   1. `metric: proposals`
   2. `targetOrganismId: <boundaryId>`
3. Threshold a variable organism with:
   1. `computation.mode: observation-sum`
   2. `computation.sensorLabel` matching the sensor `label`
   3. `computation.metric: proposals`
4. Threshold a response policy organism with:
   1. `mode: variable-threshold`
   2. `variableLabel` matching the variable `label`
5. Compose sensor, variable, and response policy as children of the boundary.
6. Integrate a proposal on the boundary (`POST /proposals/:id/integrate`).
7. Run `pnpm regulator:run`.
8. Verify:
   1. Sensor events exist: `GET /organisms/:sensorId/events?type=organism.observed`
   2. Variable state value changed: `GET /organisms/:variableId/states`
   3. Response policy `currentVariableValue` changed: `GET /organisms/:policyId/states`

## Recipe B: Proposal Integration -> GitHub Issue -> Sensor -> Action

Goal: integrated proposals produce external issue signals that drive regulator actions.

1. Compose a `github-repository` organism inside the boundary.
2. Configure:
   1. `GITHUB_ISSUE_AUTOMATION_ENABLED=true`
   2. `GITHUB_ALLOWED_REPOS=owner/repository`
   3. `GITHUB_TOKEN=<token>`
3. Integrate a proposal on the boundary.
4. Run `pnpm github:dispatch-issues`.
5. Verify issue twin exists (query by proposal lineage or inspect new `github-issue` organism).
6. Configure GitHub webhook to `POST /integrations/github/webhooks`.
7. Configure:
   1. `GITHUB_ISSUE_SENSOR_ORGANISM_ID=<sensorId>`
   2. Optional `GITHUB_WEBHOOK_SECRET=<secret>`
8. Send/receive issue webhook events.
9. Run `pnpm regulator:run`.
10. Verify action behavior:
   1. Direct execution path: runtime event indicates success and action state has `lastExecutedAt`
   2. Proposal-required path: new proposal exists on boundary

## Runtime Environment Reference

Core:

1. `REGULATOR_BOUNDARY_ORGANISM_IDS` comma-separated boundary organism IDs
2. `REGULATOR_RUNNER_USER_ID` user that runs append/proposal actions in regulator runtime

GitHub issue dispatch:

1. `GITHUB_ISSUE_AUTOMATION_ENABLED`
2. `GITHUB_ALLOWED_REPOS`
3. `GITHUB_TOKEN`
4. Optional `GITHUB_ISSUE_DISPATCH_BATCH_SIZE`
5. Optional `GITHUB_ISSUE_DISPATCH_MAX_ATTEMPTS`
6. Optional `GITHUB_API_BASE_URL`

GitHub webhook observation:

1. `GITHUB_ISSUE_SENSOR_ORGANISM_ID`
2. Optional `GITHUB_WEBHOOK_SECRET`

Regulator action guardrails:

1. Optional `REGULATOR_ALLOWED_BASE_BRANCHES`
2. Optional `REGULATOR_ALLOWED_TARGET_ORGANISM_IDS`

## Authority and Access Rules

1. `record-observation` requires stewardship or integration-authority on the sensor organism.
2. The observation actor must also have `view` on the target organism.
3. Proposal integration observation actor resolution order:
   1. Integrator user
   2. `REGULATOR_RUNNER_USER_ID` (if set)
   3. Sensor relationships (`stewardship`, then `integration-authority`)
4. Use a consistent steward for boundary + loop organisms when possible. It avoids delegated-authority gaps.

## Important Matching Rules

1. Sensor/variable wiring is by label, not organism ID:
   1. `variable.computation.sensorLabel` must equal `sensor.label`
2. Variable/response policy wiring is by label:
   1. `response-policy.variableLabel` must equal `variable.label`
3. Action trigger wiring is by organism ID:
   1. `action.trigger.responsePolicyOrganismId` must equal response policy organism ID
4. Duplicate labels in the same boundary are ambiguous. Use unique labels per boundary.

## Open-Trunk Guidance

Set loop organisms to open-trunk when the runtime needs to append state directly:

1. Variable organism: recommended open-trunk
2. Response policy organism: recommended open-trunk
3. Action organism: recommended open-trunk (metadata append path)

## API Endpoints Used In This Playbook

1. `POST /organisms` (threshold)
2. `POST /organisms/:id/children` (compose)
3. `POST /organisms/:id/proposals` (open proposal)
4. `POST /proposals/:id/integrate` (integrate)
5. `POST /organisms/:id/observations` (manual observation recording)
6. `POST /integrations/github/webhooks` (GitHub issue events)
7. `GET /organisms/:id/events` (verification)
8. `GET /organisms/:id/states` (verification)

## Troubleshooting

No variable updates after regulator run:

1. Confirm sensor events exist on the sensor organism.
2. Confirm metric match between observation events and variable computation.
3. Confirm `sensorLabel` equals sensor `label`.
4. Confirm boundary ID is included in `REGULATOR_BOUNDARY_ORGANISM_IDS`.

No response policy updates:

1. Confirm `response-policy.variableLabel` equals variable `label`.
2. Confirm variable exists as a direct child of the same boundary.

No action execution:

1. Confirm trigger decision matches `action.trigger.whenDecision`.
2. Confirm cooldown window is not active.
3. Confirm allowlists permit branch/target/repository.
4. Confirm idempotency did not already reserve and complete this action key.

No GitHub issue dispatch:

1. Confirm `GITHUB_ISSUE_AUTOMATION_ENABLED=true`.
2. Confirm a `github-repository` organism is composed in the boundary.
3. Confirm repository is in `GITHUB_ALLOWED_REPOS`.
4. Run `pnpm github:dispatch-issues` and check worker output.

No webhook observations:

1. Confirm `GITHUB_ISSUE_SENSOR_ORGANISM_ID` points to an existing sensor organism.
2. Confirm webhook route receives `issues` events.
3. Confirm observation actor has sensor authority and target visibility.

## Verification References

Behavior and payload references live in:

1. `packages/content-types/src/__tests__/cybernetic-loop.test.ts`
2. `packages/api/src/__tests__/github-regulator.test.ts`
3. `packages/api/src/__tests__/github-integration-routes.test.ts`
4. `packages/api/src/regulator/regulator-runtime.ts`
5. `packages/api/src/github/github-integration-routes.ts`
